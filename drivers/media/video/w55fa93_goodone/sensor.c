/* sensor.c
 *
 * Copyright (c) 2008 Nuvoton technology corporation
 * All rights reserved.
 * <clyu2@nuvoton.com>
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 */

#include <linux/config.h>
#include <linux/kernel.h>
#include <linux/sched.h>
#include <linux/list.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/mm.h>
#include <linux/dma-mapping.h>
#include <linux/interrupt.h>
#include <linux/smp_lock.h>
#include <linux/vmalloc.h>
#include <linux/init.h>
#include <linux/spinlock.h>
#include <linux/delay.h>
#include <linux/videodev.h>
#include <linux/jiffies.h>
#include <asm/arch/videoin.h>
#include <asm/arch/DrvVideoin.h>
//#include <asm/arch/DrvFsc.h>
#include <asm/arch/w55fa93_reg.h>
#include <asm/arch/fb.h>
#include <asm/arch/w55fa93_fb.h>
#include <asm/arch/w55fa93_gpio.h>

#include <asm/io.h>
#include <linux/i2c.h>

#include "videoinpriv.h"
#include "DrvFsc.h"
#include "DrvI2C.h"

//#define LCDWIDTH	480
//#define LCDHEIGHT	272
//#define LCDBPP		16
/*add by mlsdev008 8/12/2011*/
//#define MVFP_FLIPUP		0x08	//0b00001000
#ifndef MVFP_FLIPUP
#define MVFP_FLIPUP		0x10	//0b00010000
#endif
#define MVFP_MIRROR		0x04	//0b00000100

#define CONFIG_ARCH_W55FA93_DEMOBOARD
//IMPORT_SYMBOL(w55fa93_FB_BG_PHY_ADDR);
extern unsigned int w55fa93_FB_BG_PHY_ADDR;


#define DrvVideoIn_ov6880 1
#define DrvVideoIn_ov7648 2
#define DrvVideoIn_ov7670 3
#define DrvVideoIn_ov2640 4
#define DrvVideoIn_ov9660 5
#define DrvVideoIn_ov9653 6

#define _REG_TABLE_SIZE(nTableName)	sizeof(nTableName)/sizeof(struct OV_RegValue)

#define ERR_PRINTF			printk
#define outp32(addr, value)		outl(value, addr)
#define inp32(addr)			inl(addr)
#define DBG_PRINTF(...)
extern videoIn_buf_t videoIn_buf[];

struct OV_RegValue{
	__u8	uRegAddr;
	__u8	uValue;
};

struct OV_RegTable{
	struct OV_RegValue *sRegTable;
	__u16 uTableSize;
};


struct OV_RegValue g_sOV7670_RegValue[] =
{
#if 0
	{0x12,0x80},{0x11,0x80}/*{0x11,0x83}*/,{0x1e,0x11},{0x3a,0x04},{0x12,0x00},{0x17,0x13},{0x18,0x02},{0x32,0x80},//{0x17,0x13},{0x18,0x01},{0x32,0xb6},
	{0x19,0x03},{0x1a,0x7b},{0x03,0x0a},{0x0c,0x00},{0x3e,0x00},{0x70,0x3a},{0x71,0x35},{0x72,0x11},
	{0x73,0xf0},{0xa2,0x02},{0x7a,0x20},{0x7b,0x1c},{0x7c,0x28},{0x7d,0x3c},{0x7e,0x5a},{0x7f,0x68},
	{0x80,0x76},{0x81,0x80},{0x82,0x88},{0x83,0x8f},{0x84,0x96},{0x85,0xa3},{0x86,0xaf},{0x87,0xc4},
	{0x88,0xd7},{0x89,0xe8},{0x13,0xe0},{0x00,0x00},{0x10,0x00},{0x0d,0x40},{0x14,0x38},{0xa5,0x05},
	{0xab,0x07},{0x24,0x95},{0x25,0x33},{0x26,0xe3},{0x9f,0x78},{0xa0,0x68},{0xa1,0x0b},{0xa6,0xd8},
	{0xa7,0xd8},{0xa8,0xf0},{0xa9,0x90},{0xaa,0x94},{0x13,0xe5},{0x0e,0x61},{0x0f,0x4b},{0x16,0x02},
	{0x21,0x02},{0x22,0x91},{0x29,0x07},{0x33,0x03},{0x35,0x0b},{0x37,0x1c},{0x38,0x71},{0x3c,0x78},
	{0x4d,0x40},{0x4e,0x20},{0x69,0x55},//{0x6b,0x4a},
	{0x74,0x19},{0x8d,0x4f},{0x8e,0x00},{0x8f,0x00},
	{0x90,0x00},{0x91,0x00},{0x96,0x00},{0x9a,0x80},{0xb0,0x8c},{0xb1,0x0c},{0xb2,0x0e},{0xb3,0x82},
	{0xb8,0x0a},{0x43,0x14},{0x44,0xf0},{0x45,0x34},{0x46,0x58},{0x47,0x28},{0x48,0x3a},{0x59,0x88},
	{0x5a,0x88},{0x5b,0x44},{0x5c,0x67},{0x5d,0x49},{0x5e,0x0e},{0x6c,0x0a},{0x6d,0x55},{0x6e,0x11},
	{0x6f,0x9f},{0x6a,0x40},{0x01,0x40},{0x02,0x40},{0x13,0xe7},{0x4f,0x80},{0x50,0x80},{0x51,0x00},
	{0x52,0x22},{0x53,0x5e},{0x54,0x80},{0x58,0x9e},{0x41,0x0A}/*{0x41,0x08}*/,{0x3f,0x00},{0x75,0x05},{0x76,0x61},
	{0x4c,0x00},{0x77,0x01},{0x3d,0xc2},{0x4b,0x09},{0xc9,0x60},{0x41,0x38},{0x56,0x40},{0x34,0x11},
	{0x3b,0x02},{0xa4,0x88},{0x96,0x00},{0x97,0x30},{0x98,0x20},{0x99,0x20},{0x9a,0x84},{0x9b,0x29},
	{0x9c,0x03},{0x9d,0x4c},{0x9e,0x3f},{0x78,0x04},{0x79,0x01},{0xc8,0xf0},{0x79,0x0f},{0xc8,0x20},
	{0x79,0x10},{0xc8,0x7e},{0x79,0x0b},{0xc8,0x01},{0x79,0x0c},{0xc8,0x07},{0x79,0x0d},{0xc8,0x20},
	{0x79,0x09},{0xc8,0x80},{0x79,0x02},{0xc8,0xc0},{0x79,0x03},{0xc8,0x40},{0x79,0x05},{0xc8,0x30},
	{0x79,0x26}
#else
	{0x12, 0x80},{0x11, 0x80},{0x3A, 0x04},{0x12, 0x00},{0x17, 0x13},{0x18, 0x01},{0x32, 0xB6},
	{0x2B, 0x10},{0x19, 0x02},{0x1A, 0x7A},{0x03, 0x0F},{0x0C, 0x00},{0x3E, 0x00},{0x70, 0x3A},
	{0x71, 0x35},{0x72, 0x11},{0x73, 0xF0},{0xA2, 0x3B},{0x1E, /*0x07*/0x37},{0x7a, 0x1e},{0x7b, 0x09},
	{0x7c, 0x14},{0x7d, 0x29},{0x7e, 0x50},{0x7f, 0x5F},{0x80, 0x6C},{0x81, 0x79},{0x82, 0x84},
	{0x83, 0x8D},{0x84, 0x96},{0x85, 0xA5},{0x86, 0xB0},{0x87, 0xC6},{0x88, 0xD8},{0x89, 0xE9},
	{0x55, 0x00},{0x13, 0xE0},{0x00, 0x00},{0x10, 0x00},{0x0D, 0x60/*0x40*/},{0x42, 0x80/*0x00*/},{0x14, 0x68/*0x18*/},
	{0xA5, 0x02},{0xAB, 0x03},{0x24, 0x48},{0x25, 0x40},{0x26, 0x82},{0x9F, 0x78},{0xA0, 0x68},
	{0xA1, 0x03},{0xA6, 0xd2},{0xA7, 0xd2},{0xA8, 0xF0},{0xA9, 0x80},{0xAA, 0x14},{0x13, 0xE5},
	{0x0E, 0x61},{0x0F, 0x4B},{0x16, 0x02},{0x21, 0x02},{0x22, 0x91},{0x29, 0x07},{0x33, 0x0B},
	{0x35, 0x0B},{0x37, 0x1D},{0x38, 0x71},{0x39, 0x2A},{0x3C, 0x78},{0x4D, 0x40},{0x4E, 0x20},
	{0x69, 0x00},{0x6B, 0x0A},{0x74, 0x10},{0x8D, 0x4F},{0x8E, 0x00},{0x8F, 0x00},{0x90, 0x00},
	{0x91, 0x00},{0x96, 0x00},{0x9A, 0x80},{0xB0, 0x84},{0xB1, 0x0C},{0xB2, 0x0E},{0xB3, 0x7e},
	{0xB1, 0x00},{0xB1, 0x0c},{0xB8, 0x0A},{0x44, 0xfF},{0x43, 0x00},{0x45, 0x4a},{0x46, 0x6c},
	{0x47, 0x26},{0x48, 0x3a},{0x59, 0xd6},{0x5a, 0xff},{0x5c, 0x7c},{0x5d, 0x44},{0x5b, 0xb4},
	{0x5e, 0x10},{0x6c, 0x0a},{0x6d, 0x55},{0x6e, 0x11},{0x6f, 0x9e},{0x6A, 0x40},{0x01, 0x40},
	{0x02, 0x40},{0x13, 0xf7},{0x4f, 0x78},{0x50, 0x72},{0x51, 0x06},{0x52, 0x24},{0x53, 0x6c},
	{0x54, 0x90},{0x58, 0x1e},{0x62, 0x08},{0x63, 0x10},{0x64, 0x08},{0x65, 0x00},{0x66, 0x05},
	{0x41,0x0A}/*{0x41, 0x08}*/,{0x3F, 0x00},{0x75, 0x44},{0x76, 0xe1},{0x4C, 0x00},{0x77, 0x01},{0x3D, 0xC2},
	{0x4B, 0x09},{0xC9, 0x60},{0x41,0x1A}/*{0x41, 0x18}*/,{0x56, 0x40},{0x34, 0x11},{0x3b,0x0A}/*{0x3b, 0x02}*/,{0xa4, 0x8b/*0x89*/},
	{0x92, 0x00},{0x96, 0x00},{0x97, 0x30},{0x98, 0x20},{0x99, 0x20},{0x9A, 0x84},{0x9B, 0x29},
	{0x9C, 0x03},{0x9D, 0x99},{0x9E, 0x7F},{0x78, 0x00},{0x94, 0x08},{0x95, 0x0D},{0x79, 0x01},
	{0xc8, 0xf0},{0x79, 0x0f},{0xc8, 0x00},{0x79, 0x10},{0xc8, 0x7e},{0x79, 0x0a},{0xc8, 0x80},
	{0x79, 0x0b},{0xc8, 0x01},{0x79, 0x0c},{0xc8, 0x0f},{0x79, 0x0d},{0xc8, 0x20},{0x79, 0x09},
	{0xc8, 0x80},{0x79, 0x02},{0xc8, 0xc0},{0x79, 0x03},{0xc8, 0x40},{0x79, 0x05},{0xc8, 0x30},
	{0x79, 0x26},{0x3b,0x82}/*{0x3b, 0x82}*/,{0x43, 0x02},{0x44, 0xf2},{0xcf,0x8c}
#endif
};
#if 0
struct OV_RegValue g_sOV7648_RegValue[] =
{
	{0x12,0x80},{0x28,0x20},{0x03,0xc4},{0x04,0x30},{0x05,0x88},{0x06,0x60},{0x11,0x01},{0x12,0x05},
	{0x14,0x04},{0x15,0x14},{0x16,0x00},{0x1e,0x00},{0x1f,0x41},{0x20,0xd0},{0x23,0xde},{0x24,0x80},
	{0x25,0x70},{0x26,0x32},{0x27,0xe2},{0x2a,0x11},{0x2d,0x05},{0x2f,0x9d},{0x30,0x00},{0x31,0xc4},
	{0x60,0x86},{0x61,0xe0},{0x62,0x88},{0x63,0x11},{0x64,0x89},{0x65,0x00},{0x67,0x94},{0x68,0x7a},
	{0x69,0x08},{0x6c,0x11},{0x6d,0x33},{0x6e,0x22},{0x6f,0x00},{0x74,0x60},{0x75,0x06},{0x77,0xc4},
	{0x7a,0x80}
};

struct OV_RegValue g_sOV6880_RegValue[] =
{
	{0x12,0x80},{0x12,0x00},
	{0x0c,0x16},	// make pclk output
	{0x0d,0x30},
	{0x18,0xc8},{0x1a,0xc8},{0x5a,0xc8},{0x5b,0xc8},	// configure output size
	{0x2b,0x00},
	{0x28,0xd0},
	{0x27,0x34},{0x29,0x2C},{0x5d,0xA4},	// UV adjust
	{0x60,0x07},	// dsp control, modified from 0x67
	{0x06,0x60},	// pclk, modified from 0x40
	{0x09,0x00},	// mofified from 0x01
	{0x13,0xf5},	// modified from 0xf5, 0xf0
	{0x01,0x51},{0x02,0x40},{0x03,0x40},	// modified from {0x01,0x88}
	{0x3f,0x0e},	// PLL
	{0x30,0x00},	// modified from 0x80
	{0x24,0x45},{0x25,0x35},{0x26,0x92},	// AGC/AEC(Auto Gain Control/Auto Exposure Control)
	{0x0f,0xa1},
	{0x48,0xff},	// ADC, modified from 0xc4->this value cause image not normal
	{0x21,0x23},	// AEG
	{0x22,0x80},{0x3c,0x44},{0x3d,0xb7},{0x4c,0x80},	// reserved
	{0x5c,0x80},	// ADC
	{0x4b,0x41},	// Black sum
	{0x20,0x80},	// reserved
	{0x31,0x09},{0x32,0x00},{0x33,0x18},{0x35,0x10},{0x34,0x20},{0x36,0x20},{0x37,0x2e},
					// lens correction
	{0x43,0x08},	// BLC(Black Level Calibration)
	{0x44,0x00},{0x45,0x00},{0x46,0x00},{0x47,0x00},	// ADC
	{0x3f,0x0e},	// PLL
	{0x40,0x00},{0x41,0x00},{0x42,0x46},	// BLC
	{0x79,0x5a},{0x7a,0x4a},{0x7b,0x10},{0x7c,0x0c},{0x7d,0x7a},{0x7e,0x86},{0x7f,0x1e},
											// matrix control
	{0x66,0xf2},	// DSP
	{0x81,0x12},{0x82,0x08},{0x83,0x16},{0x84,0x30},{0x85,0x5e},	// Gamma curve
	{0x86,0x72},{0x87,0x82},{0x88,0x8e},{0x89,0x9a},{0x8a,0xa4},	// Gamma curve
	{0x8b,0xac},{0x8c,0xb8},{0x8d,0xc3},							// Gamma curve
	{0x8e,0xd6},{0x8f,0xe6},{0x90,0xf2}								// Gamma curve
};

struct OV_RegValue g_sOV2640_RegValue[] =
{
	{0xff,0x01},
	{0x12,0x80},{0xff,0x00},{0x2c,0xff},{0x2e,0xdf},{0xff,0x01},{0x3c,0x32},{0x11,0x01},{0x09,0x02},
	{0x04,0x28},{0x13,0xe5},{0x14,0x48},{0x2c,0x0c},{0x33,0x78},{0x3a,0x33},{0x3b,0xfB},{0x3e,0x00},
	{0x43,0x11},{0x16,0x10},{0x39,0x02},{0x35,0x88},{0x22,0x0a},{0x37,0x40},{0x23,0x00},{0x34,0xa0},
	{0x36,0x1a},{0x06,0x02},{0x07,0xc0},{0x0d,0xb7},{0x0e,0x01},{0x4c,0x00},{0x4a,0x81},{0x21,0x99},
	{0x24,0x40},{0x25,0x38},{0x26,0x82},{0x5c,0x00},{0x63,0x00},{0x46,0x22},{0x61,0x70},{0x62,0x80},
	{0x7c,0x05},{0x20,0x80},{0x28,0x30},{0x6c,0x00},{0x6d,0x80},{0x6e,0x00},{0x70,0x02},{0x71,0x94},
	{0x73,0xc1},{0x3d,0x34},{0x5a,0x57},{0x4f,0xbb},{0x50,0x9c},{0x12,0x40},{0x17,0x11},{0x18,0x43},
	{0x19,0x00},{0x1a,0x4b},{0x32,0x09},{0x37,0xc0},{0x4f,0xca},{0x50,0xa8},{0x6d,0x00},{0x3d,0x38},

	{0xff,0x00},
	{0xe5,0x7f},{0xf9,0xc0},{0x41,0x24},{0xe0,0x14},{0x76,0xff},{0x33,0xa0},{0x42,0x20},{0x43,0x18},
	{0x4c,0x00},{0x87,0xd0},{0x88,0x3f},{0xd7,0x03},{0xd9,0x10},{0xd3,0x82},{0xc8,0x08},{0xc9,0x80},
	{0x7c,0x00},{0x7d,0x00},{0x7c,0x03},{0x7d,0x48},{0x7d,0x48},{0x7c,0x08},{0x7d,0x20},{0x7d,0x10},
	{0x7d,0x0e},{0x90,0x00},{0x91,0x0e},{0x91,0x1a},{0x91,0x31},{0x91,0x5a},{0x91,0x69},{0x91,0x75},
	{0x91,0x7e},{0x91,0x88},{0x91,0x8f},{0x91,0x96},{0x91,0xa3},{0x91,0xaf},{0x91,0xc4},{0x91,0xd7},
	{0x91,0xe8},{0x91,0x20},{0x92,0x00},{0x93,0x06},{0x93,0xe3},{0x93,0x05},{0x93,0x05},{0x93,0x00},
	{0x93,0x04},{0x93,0x00},{0x93,0x00},{0x93,0x00},{0x93,0x00},{0x93,0x00},{0x93,0x00},{0x93,0x00},
	{0x96,0x00},{0x97,0x08},{0x97,0x19},{0x97,0x02},{0x97,0x0c},{0x97,0x24},{0x97,0x30},{0x97,0x28},
	{0x97,0x26},{0x97,0x02},{0x97,0x98},{0x97,0x80},{0x97,0x00},{0x97,0x00},{0xc3,0xed},{0xa4,0x00},
	{0xa8,0x00},{0xc5,0x11},{0xc6,0x51},{0xbf,0x80},{0xc7,0x10},{0xb6,0x66},{0xb8,0xA5},{0xb7,0x64},
	{0xb9,0x7C},{0xb3,0xaf},{0xb4,0x97},{0xb5,0xFF},{0xb0,0xC5},{0xb1,0x94},{0xb2,0x0f},{0xc4,0x5c},
	{0xc0,0x64},{0xc1,0x4B},{0x8c,0x00},{0x86,0x3D},{0x50,0x00},{0x51,0xC8},{0x52,0x96},{0x53,0x00},
	{0x54,0x00},{0x55,0x00},{0x5a,0xC8},{0x5b,0x96},{0x5c,0x00},{0xd3,0x82},{0xc3,0xed},{0x7f,0x00},
	{0xda,0x00},{0xe5,0x1f},{0xe1,0x77},{0xe0,0x00},{0xdd,0xff},{0x05,0x00}
};
#endif
struct OV_RegValue g_sOV9660_RegValue[]=
{//OV9660
		{0x12, 0x80},
	#if 1
		{0xd5, 0xff}, {0xd6, 0x3f}, {0x3d, 0x3c}, {0x11, 0x80},	{0x2a, 0x00}, {0x2b, 0x00},	//PCLK = SCLK
	#else
		{0xd5, 0xff}, {0xd6, 0x3f}, {0x3d, 0x3c}, {0x11, 0x81},	{0x2a, 0x00}, {0x2b, 0x00},	//PCLK = SCLK/2
	#endif
		{0x3a, 0xd9}, {0x3b, 0x00},	{0x3c, 0x58}, {0x3e, 0x50},	{0x71, 0x00}, {0x15, 0x00},
		{0xD7, 0x10}, {0x6a, 0x24},	{0x85, 0xe7}, {0x63, 0x00}, {0x12, 0x40}, {0x4d, 0x09},
	#if 0
		{0x17, 0x0c}, {0x18, 0x5c},	{0x19, 0x02}, {0x1a, 0x3f},	{0x03, 0x03}, {0x32, 0xb4},	//641*48?
	#else
		{0x17, 0x0b}, {0x18, 0x5c},	{0x19, 0x02}, {0x1a, 0x3f},	{0x03, 0x03}, {0x32, 0xb4}, //648x48?
	#endif
		{0x2b, 0x00}, {0x5c, 0x80},	{0x36, 0xb4}, {0x65, 0x10}, {0x70, 0x02}, {0x71, 0x9f},
		{0x64, 0xa4}, {0x5c, 0x80},	{0x43, 0x00}, {0x5D, 0x55}, {0x5E, 0x57}, {0x5F, 0x21},
		{0x24, 0x3e}, {0x25, 0x38},	{0x26, 0x72}, {0x14, 0x68}, {0x0C, 0x38}, {0x4F, 0x4f},
		{0x50, 0x42}, {0x5A, 0x67}, {0x7d, 0x30}, {0x7e, 0x00}, {0x82, 0x03}, {0x7f, 0x00},
		{0x83, 0x07}, {0x80, 0x03}, {0x81, 0x04}, {0x96, 0xf0}, {0x97, 0x00}, {0x92, 0x33},
		{0x94, 0x5a}, {0x93, 0x3a},	{0x95, 0x48}, {0x91, 0xfc}, {0x90, 0xff}, {0x8e, 0x4e},
		{0x8f, 0x4e}, {0x8d, 0x13},	{0x8c, 0x0c}, {0x8b, 0x0c},	{0x86, 0x9e}, {0x87, 0x11},
		{0x88, 0x22}, {0x89, 0x05},	{0x8a, 0x03}, {0x9b, 0x0e},	{0x9c, 0x1c}, {0x9d, 0x34},
		{0x9e, 0x5a}, {0x9f, 0x68},	{0xa0, 0x76}, {0xa1, 0x82},	{0xa2, 0x8e}, {0xa3, 0x98},
		{0xa4, 0xa0}, {0xa5, 0xb0},	{0xa6, 0xbe}, {0xa7, 0xd2},	{0xa8, 0xe2}, {0xa9, 0xee},
		{0xaa, 0x18}, {0xAB, 0xe7},	{0xb0, 0x43}, {0xac, 0x04},	{0x84, 0x40}, {0xad, 0x82},
   #if 0
		{0xd9, 0x11}, {0xda, 0x00},	{0xae, 0x10}, {0xab, 0xe7},	{0xb9, 0x50}, {0xba, 0x3c},		//641*48?
		{0xbb, 0x50}, {0xbc, 0x3c},	{0xbd, 0x8},  {0xbe, 0x19},	{0xbf, 0x2},  {0xc0, 0x8},
   #else
		{0xd9, 0x11}, {0xda, 0x00},	{0xae, 0x10}, {0xab, 0xe7},	{0xb9, 0x51}, {0xba, 0x3c},		//648x48?
		{0xbb, 0x51}, {0xbc, 0x3c},	{0xbd, 0x8},  {0xbe, 0x19},	{0xbf, 0x2},  {0xc0, 0x8},
   #endif
		{0xc1, 0x2a}, {0xc2, 0x34},	{0xc3, 0x2d}, {0xc4, 0x2d},	{0xc5, 0x0},  {0xc6, 0x98},
		{0xc7, 0x18}, {0x69, 0x48},	{0x74, 0xc0}, {0x7c, 0x28},	{0x65, 0x11}, {0x66, 0x00},
		{0x41, 0xc0}, {0x5b, 0x24},	{0x60, 0x82}, {0x05, 0x07},	{0x03, 0x03}, {0xd2, 0x94},
		{0xc8, 0x06}, {0xcb, 0x40},	{0xcc, 0x40}, {0xcf, 0x00},	{0xd0, 0x20}, {0xd1, 0x00},
		{0xc7, 0x18}, {0x0d, 0x92},	{0x0d, 0x90}
};


struct OV_RegTable g_OV_InitTable[] =
{
	{0,0},
	{0,0},
	{0,0},
	{g_sOV7670_RegValue,_REG_TABLE_SIZE(g_sOV7670_RegValue)},
	{0,0},
	{g_sOV9660_RegValue,_REG_TABLE_SIZE(g_sOV9660_RegValue)},
	{0,0}
};

__u8 g_uOvDeviceID[]=
{
	0x00,		// not a device ID
	0xc0,		// ov6680
	0x42,		// ov7648
	0x42,		// ov7670
	0x60,		// ov2640
	0x60,		// 0v9660
	0x00		// not a device ID
};



static struct i2c_client *save_client;
static int sensor_detected;
static unsigned short ignore[] = { I2C_CLIENT_END };

#ifdef CONFIG_SENSOR_OV9660
static unsigned short normal_addr[] = { 0x30, I2C_CLIENT_END };
#elif defined  CONFIG_SENSOR_OV7670
static unsigned short normal_addr[] = { 0x21, I2C_CLIENT_END };
#else
static unsigned short normal_addr[] = { 0x21, I2C_CLIENT_END };
#endif

static struct i2c_client_address_data addr_data = {
	.normal_i2c = normal_addr,
	.probe = ignore,
	.ignore = ignore,
};

static int sensor_i2c_probe(struct i2c_adapter *adap, int addr, int kind);

static int sensor_i2c_attach(struct i2c_adapter *adap)
{
	DBG_PRINTF("%s\n",__FUNCTION__);
	sensor_detected = i2c_probe(adap, &addr_data, sensor_i2c_probe);
	return sensor_detected;
}

static int sensor_i2c_detach(struct i2c_client *client)
{
	int rc;
	DBG_PRINTF("%s\n",__FUNCTION__);
	if ((rc = i2c_detach_client(client)) == 0) {
		kfree(i2c_get_clientdata(client));
	}
	return rc;
}

static struct i2c_driver sensor_i2c_driver = {
	.driver = {
		.name	= "Sensor I2C",
	},

#ifdef CONFIG_SENSOR_OV9660
	.id = 0x60,
#elif defined  CONFIG_SENSOR_OV7670
	.id = 0x42,
#else
	.id = 0x42,
#endif

	.attach_adapter = sensor_i2c_attach,
	.detach_client = sensor_i2c_detach,
};

static int sensor_i2c_probe(struct i2c_adapter *adap, int addr, int kind)
{
	struct i2c_client *client;
	int rc;
	//DBG_PRINTF("%s\n",__FUNCTION__);
	client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
	if (!client)
		return -ENOMEM;

	strncpy(client->name, "Sensor I2C", 6);
	client->addr = addr;
	client->adapter = adap;
	client->driver = &sensor_i2c_driver;

	if ((rc = i2c_attach_client(client)) != 0) {
		kfree(client);
		return rc;
	}

	save_client = client;

	return 1;
}

BOOL
I2C_Write_8bitSlaveAddr_8bitReg_8bitData(UINT8 uAddr, UINT8 uRegAddr, UINT8 uData)
{
	// 3-Phase(ID address, regiseter address, data(8bits)) write transmission
	volatile u32Delay = 0x100;
	DrvI2C_SendStart();
	while(u32Delay--);
	if ( (DrvI2C_WriteByte(uAddr,DrvI2C_Ack_Have,8)==FALSE) ||			// Write ID address to sensor
		 (DrvI2C_WriteByte(uRegAddr,DrvI2C_Ack_Have,8)==FALSE) ||	// Write register address to sensor
		 (DrvI2C_WriteByte(uData,DrvI2C_Ack_Have,8)==FALSE) )		// Write data to sensor
	{
		DrvI2C_SendStop();
		return FALSE;
	}
	DrvI2C_SendStop();

	if (uRegAddr==0x12 && (uData&0x80)!=0)
	{
		mdelay(20);
	}
	return TRUE;
}

UINT8 I2C_Read_8bitSlaveAddr_8bitReg_8bitData(UINT8 uAddr, UINT8 uRegAddr)
{
	UINT8 u8Data;

	// 2-Phase(ID address, register address) write transmission
	DrvI2C_SendStart();
	DrvI2C_WriteByte(uAddr,DrvI2C_Ack_Have,8);		// Write ID address to sensor
	DrvI2C_WriteByte(uRegAddr,DrvI2C_Ack_Have,8);	// Write register address to sensor
	DrvI2C_SendStop();

	// 2-Phase(ID-address, data(8bits)) read transmission
	DrvI2C_SendStart();
	DrvI2C_WriteByte(uAddr|0x01,DrvI2C_Ack_Have,8);		// Write ID address to sensor
	u8Data = DrvI2C_ReadByte(DrvI2C_Ack_Have,8);		// Read data from sensor
	DrvI2C_SendStop();

	return u8Data;
}



s8  DrvVideoIn_I2cWriteOV(__u8 uAddr, __u8 uRegAddr, __u8 uData)
{
	//DBG_PRINTF("%s\n",__FUNCTION__);
#ifdef __STANDARD_I2C__
	i2c_smbus_write_byte_data(save_client, uRegAddr, uData);
#else
	I2C_Write_8bitSlaveAddr_8bitReg_8bitData(uAddr, uRegAddr, uData);
#endif
	return TRUE;
}


__s8  DrvVideoIn_I2cReadOV(__u8 uAddr, __u8 uRegAddr)
{
	i2c_smbus_write_byte(save_client, uRegAddr);
	return i2c_smbus_read_byte(save_client);
	//return i2c_smbus_read_byte_data(save_client, uRegAddr);
}

void I2C_Delay(UINT32 u32Delay)
{
	volatile UINT32 i;
	for(;u32Delay!=0;u32Delay--)
		for(i=0;i<5;i++);
}

void OvRegConfig(__u32 nIndex)
{
  	__u32 i;
	__u16 uTableSize;
	__u8  uDeviceID;
	struct OV_RegValue *psRegValue;
	//DBG_PRINTF("%s\n",__FUNCTION__);

	//Mark due to sensor reset and power down conflict with Normal UART
	//SnrPowerDown(FALSE);
  	//SnrReset();

#ifdef __STANDARD_I2C__
	i2c_add_driver(&sensor_i2c_driver);
	if (sensor_detected)
	{
		DBG_PRINTF("Sensor I2C driver installed.\n");
	}
	else
	{
		DBG_PRINTF("Reg = 0x%x\n", inp32( REG_GPIOB_PUEN) );
		DBG_PRINTF("GPBFUN = 0x%x\n", inp32( REG_GPBFUN) );
		DBG_PRINTF("Failed to install I2C driver for sensor!!\n");
		return;
	}
#else
	DBG_PRINTF("Non Standard I2C.\n");
	DBG_PRINTF("REG_GPBFUN = 0x%x\n", inp32(REG_GPBFUN));
	DrvI2C_Open(eDRVGPIO_GPIOB,
				eDRVGPIO_PIN13,
				eDRVGPIO_GPIOB,
				eDRVGPIO_PIN14,
				(PFN_DRVI2C_TIMEDELY)I2C_Delay);

#endif
	//DBG_PRINTF("nIndex = %d\n", nIndex);
	if ( nIndex >= (sizeof(g_uOvDeviceID)/sizeof(__u8)) )
		return;

	uTableSize = g_OV_InitTable[nIndex].uTableSize;
	psRegValue = g_OV_InitTable[nIndex].sRegTable;
	uDeviceID = g_uOvDeviceID[nIndex];

	DBG_PRINTF("uDeviceID = 0x%x\n", uDeviceID);
	DBG_PRINTF("REG_GPBFUN = 0x%x\n", inp32(REG_GPBFUN));

	if ( psRegValue == 0 )
		return;


	for(i=0;i<uTableSize; i++, psRegValue++)
	{
		udelay(10);
		DrvVideoIn_I2cWriteOV(uDeviceID, (psRegValue->uRegAddr), (psRegValue->uValue));
	}

	//mls@dev03 set default contrast and brightness for OV76xx
	if (uDeviceID == 0x42)
	{
		DrvVideoIn_I2cWriteOV(uDeviceID, 0x55, 0x00);
		DrvVideoIn_I2cWriteOV(uDeviceID, 0x56, 0x40);
	}
}


#if defined(CONFIG_ARCH_W55FA93)
void SnrReset(void)
{/* GPA11 reset:	H->L->H */
	DBG_PRINTF("%s\n",__FUNCTION__);
	while(1);
	w55fa93_gpio_configure(GPIO_GROUP_A, 11);
	w55fa93_gpio_set(GPIO_GROUP_A, 11, 1);
	w55fa93_gpio_set_output(GPIO_GROUP_A, 11);
	udelay(100);
	w55fa93_gpio_set(GPIO_GROUP_A, 11, 0);	//GPIOA 11 set low
	udelay(100);
	w55fa93_gpio_set(GPIO_GROUP_A, 11, 1);	//GPIOA 11 set high
}

void SnrPowerDown(BOOL bIsEnable)
{/* GPA10 power down, Low for power down */
	DBG_PRINTF("%s\n",__FUNCTION__);
	while(1);
	w55fa93_gpio_configure(GPIO_GROUP_A, 10);
	w55fa93_gpio_set(GPIO_GROUP_A, 10, 0);
	w55fa93_gpio_set_output(GPIO_GROUP_A, 10);
	if(bIsEnable)
		w55fa93_gpio_set(GPIO_GROUP_A, 10, 1);		//GPIOA 10 set high
	else
		w55fa93_gpio_set(GPIO_GROUP_A, 10, 0);	//GPIOA 10 set low
}

#endif
UINT8 vinGCD(UINT16 m1, UINT16 m2)
{
	UINT16 m;
	if(m1<m2)
	{
		m=m1; m1=m2; m2=m;
	}
	if(m1%m2==0)
		return m2;
	else
		return (vinGCD(m2,m1%m2));
}

extern  unsigned int w55fa93_cpu_clock;
#ifdef CONFIG_FSC
void InitFrameSyncController(UINT32 u32PhyBuffer0,  UINT32 u32PhyBuffer1, UINT32 u32PhyBuffer2)
{
	/* Init FSC */
	UINT32 u32PhyAddr;
	DrvFSC_Open();
	/*CHannel 0 VideoIn-->FB--->VPOST*/
	DrvFSC_SetChannelAccessControl(eDRVFSC_VPOST_CH0_GPU_CH1,
										eDRVFSC_VIDEOIN_CH0_GPU_CH1);
	DrvFSC_SetChannelConfigure(eDRVFSC_CHANNEL_0,						// Channel 0
								TRUE,								// Channel Enable
								eDRVFSC_HARDWARE_FRAME_SYNC,		// Hardware Frame switch
								TRUE);								// Tripple buffer
	DBG_PRINTF("videoin Bufo=%x, Buf1=%x, Buf2= %x\n", u32PhyBuffer0, u32PhyBuffer1, u32PhyBuffer2);

	DrvFSC_SetChannelBaseAddr(eDRVFSC_CHANNEL_0,
								0,
								u32PhyBuffer0
								);
	DrvFSC_SetChannelBaseAddr(eDRVFSC_CHANNEL_0,
								1,
								u32PhyBuffer1
								);
	DrvFSC_SetChannelBaseAddr(eDRVFSC_CHANNEL_0,
								2,
								u32PhyBuffer2
								);
	{
		//PFN_DRVFSC_CALLBACK pfnOldCallback;
		//DrvFSC_InstallCallback(eDRVFSC_CH0_RS_INT,	 (PFN_DRVFSC_CALLBACK)pfnFSC_Ch0_ReadSwitchCallback, &pfnOldCallback);
		//DrvFSC_InstallCallback(eDRVFSC_CH0_WS_INT, (PFN_DRVFSC_CALLBACK)pfnFSC_Ch0_WriteSwitchCallback, &pfnOldCallback);
		//DrvFSC_InstallCallback(eDRVFSC_CH0_RE_INT,	 (PFN_DRVFSC_CALLBACK)pfnFSC_Ch0_ReadErrorCallback, &pfnOldCallback);
		//DrvFSC_InstallCallback(eDRVFSC_CH0_WE_INT, (PFN_DRVFSC_CALLBACK)pfnFSC_Ch0_WriteErrorCallback, &pfnOldCallback);
		//DrvFSC_EnableInt(eDRVFSC_CH0_RS_INT);
		//DrvFSC_EnableInt(eDRVFSC_CH0_WS_INT);
		//DrvFSC_EnableInt(eDRVFSC_CH0_RE_INT);
		//DrvFSC_EnableInt(eDRVFSC_CH0_WE_INT);
	}
}
#endif

s8 InitSensor(__u32 u32Sensor, videoin_priv_t *priv, UINT32 u32PhyAddr0, UINT32 u32PhyAddr1, UINT32 u32PhyAddr2)
{
	__u32 u32VideoDiv;
	__u32 u32GCD;
	__u32 u32PacStride, u32PlaStride;
	DBG_PRINTF("%s\n",__FUNCTION__);
  	//FunctionSwitch(SENSOR_ON);
#ifdef CONFIG_FSC
  	InitFrameSyncController(u32PhyAddr0, u32PhyAddr1, u32PhyAddr2);
#endif
	switch (u32Sensor)
	{//OV9660 will be 30f/s @ sensor clock 24MHz for VGA output.
		case OV_7670:
			DBG_PRINTF("Init OV_7670 \n");
			OvRegConfig(DrvVideoIn_ov7670);
			DrvVideoIn_Open(12000, 12000);
#ifndef CONFIG_FSC
			DrvVideoIn_SetBaseStartAddress(eDRVVIDEOIN_PACKET, 0, videoIn_buf[0].u32PhysAddr);
#endif
			DrvVideoIn_EnableInt(eDRVVIDEOIN_VINT);
			//DrvVideoIn_InstallCallback(eDRVVIDEOIN_VINT,
			//					(PFN_DRVVIDEOIN_CALLBACK)VideoIn_InterruptHandler,
			//					&pfnOldCallback	);	//Frame End interrupt
			DrvVideoIn_SetSensorPolarity(TRUE,
										FALSE,
										TRUE);
			DrvVideoIn_SetDataFormatAndOrder(eDRVVIDEOIN_IN_UYVY,
											eDRVVIDEOIN_IN_YUV422,
											eDRVVIDEOIN_OUT_RGB565);
			DrvVideoIn_SetCropWinStartAddr(0,					//UINT16 u16VerticalStart, 	Y
										4);					//UINT16 u16HorizontalStart, 	X
			/* Sensor subsample resolution (640, 480)*/
			DrvVideoIn_SetCropWinSize(480,		//UINT16 u16Height,
									 640);		//UINT16 u16Width;
			u32GCD = vinGCD(480,	// Preview height
							480); 	// Crop height
			DrvVideoIn_SetVerticalScaleFactor(eDRVVIDEOIN_PACKET,
											480/u32GCD,
											480/u32GCD);
			u32GCD = vinGCD(640,
							640);
			DrvVideoIn_SetHorizontalScaleFactor(eDRVVIDEOIN_PACKET,
											640/u32GCD,
											640/u32GCD);

			DrvVideoIn_SetVerticalScaleFactor(eDRVVIDEOIN_PLANAR,
											1,
											1);

			DrvVideoIn_SetHorizontalScaleFactor(eDRVVIDEOIN_PLANAR,
											1,
											1);
			DrvVideoIn_GetStride(&u32PacStride, &u32PlaStride);
			DrvVideoIn_SetStride(LCDWIDTH, u32PlaStride);
			DrvVideoIn_SetPipeEnable(FALSE,							// It means planar disable
										eDRVVIDEOIN_PACKET);		//

			DrvVideoIn_SetShadowRegister();
		break;

		case OV_9660:
			DBG_PRINTF("Init OV_9660 \n");

			OvRegConfig(DrvVideoIn_ov9660);

			DrvVideoIn_Open(12000, 12000);
#ifndef CONFIG_FSC
			DrvVideoIn_SetBaseStartAddress(eDRVVIDEOIN_PACKET, 0, videoIn_buf[0].u32PhysAddr);
#endif
			DrvVideoIn_EnableInt(eDRVVIDEOIN_VINT);
			//DrvVideoIn_InstallCallback(eDRVVIDEOIN_VINT,
			//					(PFN_DRVVIDEOIN_CALLBACK)VideoIn_InterruptHandler,
			//					&pfnOldCallback	);	//Frame End interrupt
			DrvVideoIn_SetSensorPolarity(TRUE,
										FALSE,
										TRUE);
			DrvVideoIn_SetDataFormatAndOrder(eDRVVIDEOIN_IN_UYVY,
											eDRVVIDEOIN_IN_YUV422,
											eDRVVIDEOIN_OUT_RGB565);
			DrvVideoIn_SetCropWinStartAddr(0,					//UINT16 u16VerticalStart, 	Y
										4);					//UINT16 u16HorizontalStart, 	X
			/* Sensor subsample resolution (640, 480)*/
			DrvVideoIn_SetCropWinSize(480,		//UINT16 u16Height,
									 640);		//UINT16 u16Width;
			u32GCD = vinGCD(480,
							480);
			DrvVideoIn_SetVerticalScaleFactor(eDRVVIDEOIN_PACKET,		/*272/480*/
											480/u32GCD,
											480/u32GCD);
			u32GCD = vinGCD(640,
							640);
			DrvVideoIn_SetHorizontalScaleFactor(eDRVVIDEOIN_PACKET,		/*364/640*/
											640/u32GCD,
											640/u32GCD);

			DrvVideoIn_SetVerticalScaleFactor(eDRVVIDEOIN_PLANAR,
											1,
											1);

			DrvVideoIn_SetHorizontalScaleFactor(eDRVVIDEOIN_PLANAR,
											1,
											1);
			DrvVideoIn_GetStride(&u32PacStride, &u32PlaStride);
			DrvVideoIn_SetStride(LCDWIDTH, u32PlaStride);
			DBG_PRINTF("Packet Pipe Start Address = 0x%x", priv->paddr);

			DrvVideoIn_SetPipeEnable(FALSE,							// It means planar disable
										eDRVVIDEOIN_PACKET);		//
			DrvVideoIn_SetShadowRegister();
		break;

		default:
			return FALSE;
		break;
	}	// switch (u32Sensor)
	return TRUE;
	DBG_PRINTF("Init sensor end\n");
}


void FunctionSwitch(int function)
{
	DBG_PRINTF("%s\n",__FUNCTION__);
#if 0
	switch(function)
	{
#ifdef CONFIG_SENSOR_OV7670

		case SPI0_ON:
			outl(inl(REG_PINFUN) | (SPI0PIN_EN | SPI_SSOEN), REG_PINFUN);  //enable PINs SPI
			//outl(inl(PINFUN) | (SPI_SSOEN), PINFUN);  //enable PINs SPI
			outl((inl(REG_GPIOB_OMD) | 0x4000), REG_GPIOB_OMD);		//GPIOB14 high power down sensor
  			outl(inl(REG_GPIOB_DOUT) | 0x4000, REG_GPIOB_DOUT);
			break;
		case SENSOR_ON:
			outl(inl(REG_PINFUN) & (~(SPI0PIN_EN | SPI_SSOEN)), REG_PINFUN);  //disable PINs SPI
			//outl(inl(PINFUN) & (~(SPI_SSOEN)), PINFUN);  			//disable PINs SPI
			outl((inl(REG_GPIOB_OMD) | 0x4000), REG_GPIOB_OMD);    	//GPIOB14 low power on sensor
  			outl(inl(REG_GPIOB_DOUT) &(~0x4000), REG_GPIOB_DOUT);
			break;
#endif

		default:
			break;
	}
#endif
}

/*
 * mls@dev03 20110721
 */
void mlsSensorOV76xxSetContrast(int value)
{
	//mls@dev03 20110721
	DrvVideoIn_I2cWriteOV(0x42, 0x56, value);
}

/*
 *
 */
void mlsSensorOV76xxSetBrightness(int value)
{
	//mls@dev03 20110721
	DrvVideoIn_I2cWriteOV(0x42, 0x55, value);
}

void mlsSensorOV76XXSetIR(int offon) // off = 0 on = 1
{
    if (offon) // on
    {
	DrvVideoIn_I2cWriteOV(0x42, 0x3B, 0xE2);
	DrvVideoIn_I2cWriteOV(0x42, 0xCF, 0x8C);
	DrvVideoIn_I2cWriteOV(0x42, 0x14, 0x38);
    }
    else  //off
    {
	DrvVideoIn_I2cWriteOV(0x42, 0x3B, 0x82);
	DrvVideoIn_I2cWriteOV(0x42, 0xCF, 0x8C);
	DrvVideoIn_I2cWriteOV(0x42, 0x14, 0x68);
    }
}


void mlsSensorOV76XXSetReg(char reg, char value) 
{
    DrvVideoIn_I2cWriteOV(0x42, reg, value);
}


void mlsSensorOV76XXGetReg(char reg, char* value) 
{
    char regVal;
    regVal = I2C_Read_8bitSlaveAddr_8bitReg_8bitData(0x42, reg);
    *value = regVal;
}


/*
 *
 */
void mlsSensorOV76xxFlipup()
{
	//mlsdev008 8/12/2011
	char regVal;
	regVal = I2C_Read_8bitSlaveAddr_8bitReg_8bitData(0x42, 0x1E);
	printk("value of 0x1E from device:%x\t");
	if(regVal & MVFP_FLIPUP)
	{
		regVal = regVal & ~MVFP_FLIPUP;
	}
	else
	{
		regVal = regVal | MVFP_FLIPUP;
	}
	printk("value of 0x1E after change:%x\n");
	DrvVideoIn_I2cWriteOV(0x42, 0x1E, regVal);
}
/*
 *
 */
void mlsSensorOV76xxCheckPID(char *status)
{
	char regVal;

	*status = 1;

	regVal = I2C_Read_8bitSlaveAddr_8bitReg_8bitData(0x42, 0x0A);
	printk("Camera PID 0x%2X \n",regVal);
	if (regVal != 0x76)
	{
		printk("	PID is not correct, it should be 0x76\n");
		*status = 0;
	}

	regVal = I2C_Read_8bitSlaveAddr_8bitReg_8bitData(0x42, 0x0B);
	printk("Camera VER 0x%2X \n", regVal);
	if (regVal != 0x73)
	{
		printk("	VER is not correct, it should be 0x73\n");
		*status = 0;
	}
}

